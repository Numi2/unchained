use libp2p::request_response::{Behaviour as RequestResponseBehaviour, Codec, Config, ProtocolSupport};
use serde::{Deserialize, Serialize};
use std::io;
use futures::io::{AsyncRead, AsyncWrite};
use futures::AsyncReadExt;
use futures::AsyncWriteExt;
use blake3::Hasher as Blake3Hasher;
use serde_big_array::BigArray;
// Remove unused payload import until RPC AEAD wrapping is wired end-to-end
use aes_gcm_siv::aead::{Aead as AeadSiv, KeyInit as KeyInitSiv};
use aes_gcm_siv::Aes256GcmSiv;
use hkdf::Hkdf;
use sha2::Sha256;

// Request-Response expects a type convertible to &str via AsRef<str>
pub type UnchainedRpcProtocol = String;

// Bounds
const MAX_REQUEST_BYTES: usize = 128 * 1024; // 128 KiB cap for requests
const MAX_RESPONSE_BYTES: usize = 4 * 1024 * 1024; // 4 MiB cap for responses (anchors/proofs)

#[derive(Clone, Default)]
pub struct RpcCodec;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RpcMethod {
    LatestAnchor,
    Epoch(u64),
    EpochSelectedIds(u64),
    EpochSummary(u64),
    Coin([u8; 32]),
    CoinProof([u8; 32]),
    CoinCandidate { epoch_hash: [u8; 32], coin_id: [u8; 32] },
    TransferById([u8; 32]),
}

// Reflect actual AEAD used (AES-GCM-SIV) in suite string for clarity/interoperability
pub const PINNED_SUITES: &str = "dilithium3+ed25519+kyber768+aes-256-gcm-siv";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientHelloUnsigned {
    pub handshake_version: u8,
    pub suites: String,
    pub local_peer_id: String,
    pub remote_peer_id: String,
    #[serde(with = "BigArray")]
    pub ed25519_pk: [u8; 32],
    #[serde(with = "BigArray")]
    pub dilithium_pk: [u8; crate::crypto::DILITHIUM3_PK_BYTES],
    pub expiry_unix_secs: u64,
    /// Kyber client KEM public key bound into the signed transcript
    pub client_kyber_pk: Vec<u8>,
    /// Anti-replay nonce chosen by client; verified and cached by server for short TTL
    #[serde(with = "BigArray")]
    pub nonce: [u8; 32],
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientHello {
    pub unsigned: ClientHelloUnsigned,
    pub sig_ed25519: Vec<u8>,
    #[serde(with = "BigArray")]
    pub sig_dilithium: [u8; crate::crypto::DILITHIUM3_SIG_BYTES],
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerHelloUnsigned {
    pub handshake_version: u8,
    pub suites: String,
    pub local_peer_id: String,
    pub remote_peer_id: String,
    #[serde(with = "BigArray")]
    pub ed25519_pk: [u8; 32],
    #[serde(with = "BigArray")]
    pub dilithium_pk: [u8; crate::crypto::DILITHIUM3_PK_BYTES],
    pub expiry_unix_secs: u64,
    /// Kyber ciphertext generated by the server, bound into the signed transcript
    pub kyber_ct: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerHello {
    pub unsigned: ServerHelloUnsigned,
    pub sig_ed25519: Vec<u8>,
    #[serde(with = "BigArray")]
    pub sig_dilithium: [u8; crate::crypto::DILITHIUM3_SIG_BYTES],
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RpcRequest {
    pub request_id: u64,
    pub stream_id: u64,
    pub client_hello: ClientHello,
    // AEAD-encrypted request (c->s). Client-provided Kyber ciphertext binds nonce schedule.
    pub client_kyber_ct: Vec<u8>,
    pub method_enc: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RpcResponsePayload {
    Anchor(Option<crate::epoch::Anchor>),
    EpochSelectedIds(Option<EpochSelected>),
    EpochSummary(Option<EpochSummary>),
    Coin(Option<crate::coin::Coin>),
    CoinProof(Option<(crate::coin::Coin, crate::epoch::Anchor, Vec<([u8; 32], bool)>)>),
    CoinCandidate(Option<crate::coin::CoinCandidate>),
    Transfer(Option<crate::transfer::Transfer>),
    Error(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpochSummary {
    pub anchor: crate::epoch::Anchor,
    pub selected_coin_ids: Vec<[u8;32]>,
    pub coins: Vec<crate::coin::Coin>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpochSelected {
    pub epoch: u64,
    pub ids: Vec<[u8;32]>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkProof {
    pub coin_id: [u8;32],
    pub work: [u8;32],
    pub merkle_proof: Vec<([u8;32], bool)>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RpcResponse {
    pub request_id: u64,
    pub stream_id: u64,
    pub server_hello: ServerHello,
    // AEAD encrypted payload (s->c). Nonce/AAD are derived deterministically per spec.
    pub kyber_ct: Vec<u8>,
    pub payload_enc: Vec<u8>,
}

#[async_trait::async_trait]
impl Codec for RpcCodec {
    type Protocol = UnchainedRpcProtocol;
    type Request = RpcRequest;
    type Response = RpcResponse;

    async fn read_request<T>(&mut self, _protocol: &Self::Protocol, io: &mut T) -> io::Result<Self::Request>
    where
        T: AsyncRead + Unpin + Send,
    {
        let mut len_buf = [0u8; 4];
        io.read_exact(&mut len_buf).await?;
        let len = u32::from_be_bytes(len_buf) as usize;
        if len == 0 || len > MAX_REQUEST_BYTES {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "request size out of bounds"));
        }
        let mut buf = vec![0u8; len];
        io.read_exact(&mut buf).await?;
        bincode::deserialize(&buf).map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "bad request bincode"))
    }

    async fn read_response<T>(&mut self, _protocol: &Self::Protocol, io: &mut T) -> io::Result<Self::Response>
    where
        T: AsyncRead + Unpin + Send,
    {
        let mut len_buf = [0u8; 4];
        io.read_exact(&mut len_buf).await?;
        let len = u32::from_be_bytes(len_buf) as usize;
        if len == 0 || len > MAX_RESPONSE_BYTES {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "response size out of bounds"));
        }
        let mut buf = vec![0u8; len];
        io.read_exact(&mut buf).await?;
        bincode::deserialize(&buf).map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "bad response bincode"))
    }

    async fn write_request<T>(&mut self, _protocol: &Self::Protocol, io: &mut T, req: Self::Request) -> io::Result<()>
    where
        T: AsyncWrite + Unpin + Send,
    {
        let bytes = bincode::serialize(&req).map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "serialize req"))?;
        if bytes.len() > MAX_REQUEST_BYTES {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "request too large"));
        }
        io.write_all(&(bytes.len() as u32).to_be_bytes()).await?;
        io.write_all(&bytes).await?;
        io.flush().await
    }

    async fn write_response<T>(&mut self, _protocol: &Self::Protocol, io: &mut T, resp: Self::Response) -> io::Result<()>
    where
        T: AsyncWrite + Unpin + Send,
    {
        let bytes = bincode::serialize(&resp).map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "serialize resp"))?;
        if bytes.len() > MAX_RESPONSE_BYTES {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "response too large"));
        }
        io.write_all(&(bytes.len() as u32).to_be_bytes()).await?;
        io.write_all(&bytes).await?;
        io.flush().await
    }
}

pub type RpcBehaviour = RequestResponseBehaviour<RpcCodec>;

pub fn build_rpc_behaviour() -> RpcBehaviour {
    let protocols = std::iter::once(("/unchained/rpc/1".to_string(), ProtocolSupport::Full));
    let cfg = Config::default();
    RequestResponseBehaviour::<RpcCodec>::new(protocols, cfg)
}

// No extra RpcEvent wrapper; network listens to RequestResponse events directly.

// === Key derivation and AEAD helpers ===
// Invariants for misuse-resistance:
// - request_id is monotonic per stream (enforced by caller in network.rs)
// - Kyber ciphertexts are freshly generated per request (client C2S, server S2C)
// - We derive a per-request AEAD subkey from the transcript master using (request_id, dir)

#[derive(Copy, Clone)]
pub enum Direction { C2S, S2C }

fn blake3_concat(parts: &[&[u8]]) -> [u8; 32] {
    let mut h = Blake3Hasher::new_derive_key("unchained/hs");
    for p in parts { h.update(p); }
    *h.finalize().as_bytes()
}

fn hkdf_master_keys(kyber_ss: &[u8], client_u: &ClientHelloUnsigned, server_u: &ServerHelloUnsigned, role: &str) -> ([u8;32],[u8;32]) {
    let enc_client = bincode::serialize(client_u).unwrap_or_default();
    let enc_server = bincode::serialize(server_u).unwrap_or_default();
    let salt = blake3_concat(&[b"unchained/hs", &enc_client, &enc_server]);
    let info = [
        b"unchained/ikm".as_slice(),
        client_u.local_peer_id.as_bytes(),
        client_u.remote_peer_id.as_bytes(),
        client_u.suites.as_bytes(),
        role.as_bytes(),
    ].concat();
    let hk = Hkdf::<Sha256>::new(Some(&salt), kyber_ss);
    let mut okm = [0u8; 64];
    hk.expand(&info, &mut okm).expect("hkdf expand");
    let mut c2s = [0u8;32]; c2s.copy_from_slice(&okm[..32]);
    let mut s2c = [0u8;32]; s2c.copy_from_slice(&okm[32..]);
    (c2s,s2c)
}

pub fn stream_key(master: &[u8;32], stream_id: u64, dir: Direction) -> [u8;32] {
    let mut ctx = Blake3Hasher::new_derive_key("unchained/rpc/stream");
    ctx.update(master);
    ctx.update(&stream_id.to_le_bytes());
    ctx.update(&[match dir { Direction::C2S=>0, Direction::S2C=>1 }]);
    *ctx.finalize().as_bytes()
}

#[allow(dead_code)]
fn aead_nonce(stream_id: u64, request_id: u64, dir: Direction) -> [u8;12] {
    let mut ctx = Blake3Hasher::new_derive_key("unchained/rpc/nonce");
    ctx.update(&stream_id.to_le_bytes());
    ctx.update(&request_id.to_le_bytes());
    ctx.update(&[match dir { Direction::C2S=>0, Direction::S2C=>1 }]);
    let full = ctx.finalize();
    let mut out = [0u8;12];
    out.copy_from_slice(&full.as_bytes()[..12]);
    out
}

fn aead_nonce_s2c_from_kyber(kyber_ct: &[u8], request_id: u64) -> [u8;12] {
    // Server-controlled nonce schedule bound to server-generated Kyber ciphertext
    let mut ctx = Blake3Hasher::new_derive_key("unchained/rpc/nonce/s2c");
    ctx.update(&(request_id.to_le_bytes()));
    ctx.update(kyber_ct);
    let full = ctx.finalize();
    let mut out = [0u8;12];
    out.copy_from_slice(&full.as_bytes()[..12]);
    out
}

fn derive_per_request_key(master: &[u8;32], request_id: u64, dir: Direction) -> [u8;32] {
    let mut h = Blake3Hasher::new_derive_key("unchained/rpc/subkey");
    h.update(master);
    h.update(&request_id.to_le_bytes());
    h.update(&[match dir { Direction::C2S => 0, Direction::S2C => 1 }]);
    *h.finalize().as_bytes()
}

pub fn aead_encrypt_s2c(key: &[u8;32], kyber_ct: &[u8], request_id: u64, aad_extra: &[u8], plaintext: &[u8]) -> Vec<u8> {
    // Use AES-GCM-SIV (misuse-resistant) to guard against nonce reuse bugs. Nonce is still server-derived schedule.
    let subkey = derive_per_request_key(key, request_id, Direction::S2C);
    let aead = Aes256GcmSiv::new_from_slice(&subkey).expect("aead init");
    let nonce = aead_nonce_s2c_from_kyber(kyber_ct, request_id);
    let aad = [
        &[1u8][..], // S2C
        &request_id.to_le_bytes(),
        aad_extra,
    ].concat();
    aead.encrypt((&nonce).into(), aes_gcm_siv::aead::Payload { msg: plaintext, aad: &aad }).expect("encrypt")
}

pub fn aead_decrypt_s2c(key: &[u8;32], kyber_ct: &[u8], request_id: u64, aad_extra: &[u8], ciphertext: &[u8]) -> Option<Vec<u8>> {
    let subkey = derive_per_request_key(key, request_id, Direction::S2C);
    let aead = Aes256GcmSiv::new_from_slice(&subkey).ok()?;
    let nonce = aead_nonce_s2c_from_kyber(kyber_ct, request_id);
    let aad = [
        &[1u8][..], // S2C
        &request_id.to_le_bytes(),
        aad_extra,
    ].concat();
    aead.decrypt((&nonce).into(), aes_gcm_siv::aead::Payload { msg: ciphertext, aad: &aad }).ok()
}

pub fn derive_stream_keys_and_dirs(kyber_ss: &[u8], client_u: &ClientHelloUnsigned, server_u: &ServerHelloUnsigned) -> ([u8;32],[u8;32]) {
    let (c2s_master, s2c_master) = hkdf_master_keys(kyber_ss, client_u, server_u, "server");
    (c2s_master, s2c_master)
}

// === Client-to-Server AEAD (C2S) ===

fn aead_nonce_c2s_from_kyber(client_kyber_ct: &[u8], request_id: u64) -> [u8;12] {
    // Client-controlled nonce schedule bound to client-generated Kyber ciphertext
    let mut ctx = Blake3Hasher::new_derive_key("unchained/rpc/nonce/c2s");
    ctx.update(&(request_id.to_le_bytes()));
    ctx.update(client_kyber_ct);
    let full = ctx.finalize();
    let mut out = [0u8;12];
    out.copy_from_slice(&full.as_bytes()[..12]);
    out
}

pub fn aead_encrypt_c2s(key: &[u8;32], client_kyber_ct: &[u8], request_id: u64, aad_extra: &[u8], plaintext: &[u8]) -> Vec<u8> {
    let subkey = derive_per_request_key(key, request_id, Direction::C2S);
    let aead = Aes256GcmSiv::new_from_slice(&subkey).expect("aead init");
    let nonce = aead_nonce_c2s_from_kyber(client_kyber_ct, request_id);
    let aad = [
        &[0u8][..], // C2S
        &request_id.to_le_bytes(),
        aad_extra,
    ].concat();
    aead.encrypt((&nonce).into(), aes_gcm_siv::aead::Payload { msg: plaintext, aad: &aad }).expect("encrypt")
}

pub fn aead_decrypt_c2s(key: &[u8;32], client_kyber_ct: &[u8], request_id: u64, aad_extra: &[u8], ciphertext: &[u8]) -> Option<Vec<u8>> {
    let subkey = derive_per_request_key(key, request_id, Direction::C2S);
    let aead = Aes256GcmSiv::new_from_slice(&subkey).ok()?;
    let nonce = aead_nonce_c2s_from_kyber(client_kyber_ct, request_id);
    let aad = [
        &[0u8][..], // C2S
        &request_id.to_le_bytes(),
        aad_extra,
    ].concat();
    aead.decrypt((&nonce).into(), aes_gcm_siv::aead::Payload { msg: ciphertext, aad: &aad }).ok()
}

/// Derive a C2S master key from the client's Kyber shared secret and the transcript
/// components known at request time.
pub fn derive_c2s_master(
    client_kyber_ss: &[u8],
    client_u: &ClientHelloUnsigned,
    server_ed25519_pk: &[u8;32],
    server_dilithium_pk: &[u8; crate::crypto::DILITHIUM3_PK_BYTES],
) -> [u8;32] {
    // Salt binds client hello and server static keys
    let enc_client = bincode::serialize(client_u).unwrap_or_default();
    let mut salt_hasher = Blake3Hasher::new_derive_key("unchained/hs/c2s");
    salt_hasher.update(&enc_client);
    salt_hasher.update(server_ed25519_pk);
    salt_hasher.update(server_dilithium_pk);
    let salt = *salt_hasher.finalize().as_bytes();

    let info = [
        b"unchained/c2s".as_slice(),
        client_u.local_peer_id.as_bytes(),
        client_u.remote_peer_id.as_bytes(),
        client_u.suites.as_bytes(),
    ].concat();
    let hk = Hkdf::<Sha256>::new(Some(&salt), client_kyber_ss);
    let mut okm = [0u8;32];
    hk.expand(&info, &mut okm).expect("hkdf expand");
    okm
}

/// Build a server hello and seal the response payload using the derived S2C key.
/// Returns the populated `RpcResponse` structure.
pub fn seal_response(
    request_id: u64,
    stream_id: u64,
    client_u: ClientHelloUnsigned,
    server_ed25519_pk: [u8;32],
    server_pq_pk: [u8; crate::crypto::DILITHIUM3_PK_BYTES],
    server_sign_ed25519: impl Fn(&[u8]) -> Vec<u8>,
    server_sign_pq: impl Fn(&[u8]) -> [u8; crate::crypto::DILITHIUM3_SIG_BYTES],
    // Kyber encapsulation function that returns (ciphertext, shared_secret)
    server_kyber_encaps: impl Fn(&[u8]) -> (Vec<u8>, Vec<u8>),
    suites: &str,
    local_peer_id: &str,
    remote_peer_id: &str,
    payload: &RpcResponsePayload,
) -> RpcResponse {
    // Create unsigned server hello and bind Kyber ct
    let (kyber_ct, kyber_ss) = server_kyber_encaps(&client_u.client_kyber_pk);
    let server_u = ServerHelloUnsigned {
        handshake_version: 1,
        suites: suites.to_string(),
        local_peer_id: local_peer_id.to_string(),
        remote_peer_id: remote_peer_id.to_string(),
        ed25519_pk: server_ed25519_pk,
        dilithium_pk: server_pq_pk,
        expiry_unix_secs: (std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs()) + 300,
        kyber_ct: kyber_ct.clone(),
    };
    let ser_u = bincode::serialize(&server_u).unwrap_or_default();
    let sig_ed = server_sign_ed25519(&ser_u);
    let sig_pq = server_sign_pq(&ser_u);
    let server_hello = ServerHello { unsigned: server_u.clone(), sig_ed25519: sig_ed, sig_dilithium: sig_pq };

    // Derive S2C master and encrypt payload
    let (_c2s, s2c) = derive_stream_keys_and_dirs(&kyber_ss, &client_u, &server_u);
    let aad_extra = bincode::serialize(&(&client_u, &server_u)).unwrap_or_default();
    let plaintext = bincode::serialize(payload).unwrap_or_default();
    let payload_enc = aead_encrypt_s2c(&s2c, &kyber_ct, request_id, &aad_extra, &plaintext);
    RpcResponse { request_id, stream_id, server_hello, kyber_ct, payload_enc }
}

/// Open and authenticate a response payload given transcript material and Kyber secret.
pub fn open_response(
    resp: &RpcResponse,
    client_u: &ClientHelloUnsigned,
    server_u: &ServerHelloUnsigned,
    kyber_ss: &[u8],
) -> Option<RpcResponsePayload> {
    let (_c2s, s2c) = derive_stream_keys_and_dirs(kyber_ss, client_u, server_u);
    let aad_extra = bincode::serialize(&(client_u, server_u)).ok()?;
    let pt = aead_decrypt_s2c(&s2c, &resp.kyber_ct, resp.request_id, &aad_extra, &resp.payload_enc)?;
    bincode::deserialize::<RpcResponsePayload>(&pt).ok()
}

